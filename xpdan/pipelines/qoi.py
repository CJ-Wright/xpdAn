from xpdan.pipelines.main import *  # noqa: F403, F401
from shed.translation import ToEventStream
from xpdtools.pipelines.qoi import q_peak_pos, r_peak_pos, pdf_intensity, mean_intensity

from bluesky.callbacks.best_effort import BestEffortCallback
from bluesky.callbacks.mpl_plotting import LiveScatter
from pprint import pprint

from matplotlib.colors import LogNorm, SymLogNorm


# bec = BestEffortCallback()

class LiveMultiScatter(LiveScatter):
    """Plot scattered 2D data in a "heat map".

    Alternatively, if the data is placed on a regular grid, you can use
    :func:`bluesky.callbacks.LiveGrid`.

    This simply wraps around a `PathCollection` as generated by scatter.

    Parameters
    ----------
    x, y : str
       The fields to use for the x and y data

    I : str
        The field to use for the color of the markers

    xlim, ylim, clim : tuple, optional
       The x, y and color limits respectively

    cmap : str or colormap, optional
       The color map to use

    ax : Axes, optional
        matplotib Axes; if none specified, new figure and axes are made.

    All additional keyword arguments are passed through to ``Axes.scatter``.

    See Also
    --------
    :class:`bluesky.callbacks.LiveGrid`.
    """

    def event(self, doc):
        x = doc.get(self.x, None) or doc.get('data').get(self.x)
        y = doc.get(self.y, None) or doc.get('data').get(self.y)
        I = doc['data'][self.I]
        self.update(x, y, I)
        # super().event(doc)

    def update(self, x, y, I):
        # normalize the data across shapes
        data = [x, y, I]
        new_data = []
        shapes = [getattr(k, 'shape', None) for k in data]
        shape = [s for s in shapes if s is not None and s != (0,)][0]
        if any(shapes):
            for d, s in zip(data, shapes):
                if s is None:
                    new_data.append(np.ones(shape) * d)
                else:
                    new_data.append(d)

        # if one is None all are
        if self._minx is None:
            self._minx = np.min(data[0])
            self._maxx = np.max(data[0])
            self._miny = np.min(data[1])
            self._maxy = np.max(data[1])

        for n, d in zip(['_xdata', '_ydata', '_Idata'], new_data):
            getattr(self, n).extend(list(d))
        offsets = np.vstack([self._xdata, self._ydata]).T
        self.sc.set_offsets(offsets)
        self.sc.set_array(np.asarray(self._Idata))

        if self.xlim is None:
            minx, maxx = np.minimum(np.min(x), self._minx), np.maximum(
                np.max(x), self._maxx)
            self.ax.set_xlim(minx, maxx)

        if self.ylim is None:
            miny, maxy = np.minimum(np.min(y), self._miny), np.maximum(
                np.max(y), self._maxy)
            self.ax.set_ylim(miny, maxy)

        if self.clim is None:
            clim = np.nanmin(self._Idata), np.nanmax(self._Idata)
            self.sc.set_clim(*clim)


z = ToEventStream(q_peak_pos, ('q_peaks',)).AlignEventStreams(
    raw_source,
    ToEventStream(mean_intensity, ('mean_I', )),
    ToEventStream(pdf_intensity, ('pdf_I', )),
    ToEventStream(r_peak_pos, ('r_peaks', ))
)

# z.sink(pprint)
# z.starsink(bec)

lms = LiveMultiScatter('q_peaks', 'temperature', 'mean_I')
lms.ax.set_aspect('auto')
lms._norm = SymLogNorm(.001)
lms2 = LiveMultiScatter('r_peaks', 'temperature', 'pdf_I')
lms2.ax.set_aspect('auto')

# z.sink(pprint)
z.starsink(lms)
z.starsink(lms2)
